{-# LANGUAGE TupleSections #-}

-- |Contains the 'Successor' type which is used to
--  construct crawl trees, together with a set of useful
--  helper functions for creating 'Successor' functions.
--
--  For examples of successor functions, see @Galleries.Examples@.
module Crawling.Hephaestos.Fetch.Types.Successor (
   -- *Types
   Successor,
   HTMLSuccessor,
   htmlSuccessor,
   FetchResult(..),
   SuccessorNode(..),
   -- *Helper functions relating to state and failure
   simpleNode,
   voidNode,
   reqNode,
   noneAsFailure,
   noneAsDataFailure,
   -- *Discriminator functions
   isBlob,
   isInner,
   isBinaryData,
   isPlainText,
   isXmlResult,
   isFailure,
   isInfo,
   asBinaryData,
   asPlainText,
   asXmlResult,
   asInfo,
   ) where

import Control.Arrow
import Control.Exception
import Data.ByteString.Lazy (ByteString)
import Data.Text
import Data.Void
import Network.HTTP.Conduit (Request)
import Text.XML.HXT.DOM.TypeDefs

import Crawling.Hephaestos.Fetch.Types
import Crawling.Hephaestos.XPath

-- |A function which extracts a number of successor nodes
--  from a page.
--  'Successors' return tuples. The first component is the leaves,
--  which should not be expanded further. The second is the inner nodes, which
--  should (these should be of type 'Blob'). Each node also contains a new state
--  and a function which modifies the HTTP request. This is useful when things
--  like special referers are necessary.
type Successor e a = URL -- ^The URL of the input
                     -> ByteString -- ^The input as a byte string.
                     -> a -- ^The input state.
                     -> ([SuccessorNode e a], [SuccessorNode e a])
                        -- ^The list of resultant leaves and nodes.

-- |A Successor which only works on HTML input. See 'htmlSuccessor'.
type HTMLSuccessor e a = URL
                         -> XmlTree
                         -> a
                         -> ([SuccessorNode e a], [SuccessorNode e a])

-- |A node generated by a 'Successor' function.
--  See 'simpleNode', 'voidNode' and 'redNode' for smart constructors.
data SuccessorNode e a = SuccessorNode {nodeState::a,
                                        -- ^The new state.
                                        nodeRes::FetchResult e,
                                        -- ^The node's result. Only 'Blob's will
                                        --  be expanded.
                                        nodeReqMod::Request -> Request,
                                        -- ^Modifiers for the next HTTP request.
                                        nodeURL :: URL
                                        -- ^This node's URL
                                       }

-- |Functor instance over the node state.
instance Functor (SuccessorNode e) where
   fmap f s@SuccessorNode{nodeState=a} = s{nodeState=f a}

-- |Constructs a general 'Successor' from a 'HTMLSuccessor'. If the input
--  cannot be parsed as HTML, a failure node is created.
htmlSuccessor :: (Request -> Request) -- ^The request modifier function.
                                      --  This is necessary for the creation
                                      --  of the failure node in case the input
                                      --  can't be parsed as HTML.
              -> HTMLSuccessor SomeException a
              -> Successor SomeException a
htmlSuccessor reqF succ url bs st =
   case toDocument url bs of
      (Right html) -> succ url html st
      (Left err) -> ([SuccessorNode st (Failure err True) reqF url], [])

-- |Creates a 'SuccessorNode' from a 'FetchResult' and a state. No request
--  modifiers will be applied.
simpleNode :: a -> FetchResult e -> URL -> SuccessorNode e a
simpleNode s r = SuccessorNode s r id

-- |Creates a 'SuccessorNode' from a 'FetchResult'.
--  No request modifiers will be applied.
voidNode :: FetchResult e -> URL -> SuccessorNode e Void
voidNode = simpleNode undefined

-- |Creates a 'SuccessorNode' from a 'FetchResult' and a request modifier
--  function.
reqNode :: FetchResult e -> (Request -> Request) -> URL -> SuccessorNode e Void
reqNode = SuccessorNode undefined

-- |Result of a fetching operation.
data FetchResult e =
   -- |A URL which is to be downloaded.
   Blob
   -- |An inner node in a search treee.
   | Inner
   -- |Some plain text without any deeper semantic value.
   | PlainText{fromPlainText::Text}
   -- |A ByteString (binary data).
   | BinaryData{fromBinary::ByteString}
   -- |An XML tree.
   | XmlResult{fromXmlResult::XmlTree}
   -- |A failure which stores the URL and the error which occurred.
   --  If the failure occurred when fetching an 'Inner' node, 'failureReepand'
   --  is True; othwewise it is false.
   | Failure{failureError::e, failureReexpand::Bool}
   -- |A piece of named auxiliary information, such as a title or an author.
   | Info{infoKey::Text,infoValue::Text}
   deriving (Show, Eq)

-- |Convenience function which turns a collection of ByteStrings into
--  BinaryData FetchResults.
asBinaryData :: Functor f => f ByteString -> f (FetchResult e)
asBinaryData = fmap BinaryData

-- |Convenience function which turns a collection of Texts
--  into PlainText FetchResults.
asPlainText :: Functor f => f Text -> f (FetchResult e)
asPlainText = fmap PlainText

-- |Convenience function which turns a collection of XmlTrees
--  into XmlResult FetchResults.
asXmlResult :: Functor f => f XmlTree -> f (FetchResult e)
asXmlResult = fmap XmlResult

-- |Convenience function which turns a collection of tuples
--  into Info FetchResults.
asInfo :: Functor f => f (Text,Text) -> f (FetchResult e)
asInfo = fmap (uncurry Info)

-- |Automatically creates a failure node if the result
--  set is empty. This is useful for when at least 1 result
--  is expected.
noneAsFailure :: e -- ^The error to create.
              -> Bool -- ^The re-expand parameter. True for inner nodes,
                      -- false for leaves.
              -> [FetchResult e] -- ^The result set  @S@ to check for emptiness.
              -> [FetchResult e] -- ^@S@ if @not.null $ S@, @[f]@
                                 --  otherwise (for a new 'Failure' @f@).
noneAsFailure e b [] = [Failure e b]
noneAsFailure _ _ (x:xs) = x:xs

-- |Simpler version of 'noneAsFailure' which creates
--  a 'DataFindingError' with a default error message.
noneAsDataFailure :: URL
                  -> Bool
                  -> [FetchResult SomeException]
                  -> [FetchResult SomeException]
noneAsDataFailure url b = noneAsFailure
                          (SomeException $ dataFindingError url)
                          b

-- |Returns True iff the result is a Blob.
isBlob :: FetchResult e -> Bool
isBlob Blob{} = True
isBlob _ = False

-- |Returns True iff the result is an inner node.
isInner :: FetchResult e -> Bool
isInner Inner{} = True
isInner _ = False

-- |Returns True iff the result is binary data.
isBinaryData BinaryData{} = True
isBinaryData _ = False

-- |Returns True iff the result is plain text.
isPlainText :: FetchResult e -> Bool
isPlainText PlainText{} = True
isPlainText _ = False

-- |Returns True iff the result is an XML tree.
isXmlResult :: FetchResult e -> Bool
isXmlResult XmlResult{} = True
isXmlResult _ = False

-- |Returns True iff the result is a failure.
isFailure :: FetchResult e -> Bool
isFailure Failure{} = True
isFailure _ = False

-- |Returns True iff the result is auxiliary information.
isInfo :: FetchResult e -> Bool
isInfo Info{} = True
isInfo _ = False
